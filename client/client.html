<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sumo Arena</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<style>
  body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background: #222; 
      color: white; 
      text-align: center; 
      margin: 0; 
      overflow: hidden; 
  }

  /* --- UI LAYOUT --- */
  #game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
  }

  #controls { 
      margin-bottom: 20px; 
      z-index: 10;
  }

  /* Canvas styling */
  #arena { 
      background: #eee; 
      border-radius: 50%; 
      cursor: crosshair; 
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
      outline: none;
  }

  /* Buttons */
  button { 
      margin-top: 20px;
      padding: 15px 15px; 
      font-size: 20px; 
      font-weight: bold;
      cursor: pointer; 
      background: #4CAF50; 
      color: white; 
      border: none; 
      border-radius: 5px; 
      transition: background 0.2s, transform 0.1s;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
  }
  button:hover { background: #45a049; transform: scale(1.05); }
  button:active { transform: scale(0.95); }
  button:disabled { background: #555; cursor: not-allowed; transform: none; }

  /* Status Text */
  #statusText { margin-top: 15px; font-size: 18px; color: #ccc; height: 24px; }

  /* --- GAME OVER MODAL --- */
  #gameOverModal {
      display: none; 
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.85); 
      z-index: 1000;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(5px);
  }

  .modal-content {
      background: #2a2a2a;
      padding: 50px;
      border-radius: 15px;
      border: 2px solid #555;
      text-align: center;
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
      animation: popIn 0.3s ease-out;
  }

  @keyframes popIn {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
  }

  .modal-title { color: #ff5555; font-size: 48px; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; }
  .modal-winner { color: #fff; font-size: 24px; margin: 0 0 40px 0; }
  
  #restartBtn { background: #2196F3; }
  #restartBtn:hover { background: #0b7dda; }

  /* Debug Box */
  #debug { 
      position: fixed; top: 10px; left: 10px; 
      background: rgba(0,0,0,0.8); color: lime; 
      padding: 10px; font-family: monospace; 
      border: 1px solid lime; pointer-events: none;
      display: none; 
  }
</style>
</head>
<body>

<div id="game-container">
    <div id="controls">
        <h2 style="margin: 0 0 10px 0;">Sumo Arena</h2>
        <button id="readyBtn">I AM READY</button>
        <div id="statusText">Waiting for connection...</div>
    </div>

    <canvas id="arena" width="600" height="600" tabindex="0"></canvas>

    <div id="gameOverModal">
        <div class="modal-content">
            <h1 class="modal-title">GAME ENDED</h1>
            <h2 id="winnerText" class="modal-winner">Winner: Player 1</h2>
            <button id="restartBtn">RESTART</button>
        </div>
    </div>
</div>

<div id="debug">Waiting for input...</div>

<script type="module">
    import setupInput from './input.js';

    // ==== 1. Setup & Assets ====
    const socket = io("http://localhost:3000");
    let playerId;
    
    // -- LOAD IMAGES (MY PLAYER) --
    const imgPlayerIdle = new Image();
    imgPlayerIdle.src = "./img/Player.png"; 

    const imgPlayerRun1 = new Image();
    imgPlayerRun1.src = "./img/Player_run_1.png";

    const imgPlayerRun2 = new Image();
    imgPlayerRun2.src = "./img/Player_run_2.png";

    // -- LOAD IMAGES (ENEMY) --
    const imgEnemyIdle = new Image();
    imgEnemyIdle.src = "./img/Player_enemy.png"; 

    const imgEnemyRun1 = new Image();
    imgEnemyRun1.src = "./img/Player_enemy_run_1.png";

    const imgEnemyRun2 = new Image();
    imgEnemyRun2.src = "./img/Player_enemy_run_2.png";

    // UI Elements
    const readyBtn = document.getElementById("readyBtn");
    const statusText = document.getElementById("statusText");
    const modal = document.getElementById("gameOverModal");
    const winnerText = document.getElementById("winnerText");
    const restartBtn = document.getElementById("restartBtn");
    const canvas = document.getElementById("arena");
    const ctx = canvas.getContext("2d");

    // !!! IMPORTANT: We capture the returned input object to check keys !!!
    const myInput = setupInput(socket);

    // ==== 2. UI LOGIC ====
    readyBtn.onclick = () => {
        socket.emit("player-ready");
        readyBtn.disabled = true;
        readyBtn.innerText = "WAITING FOR OTHERS...";
        readyBtn.style.backgroundColor = "#555";
        statusText.innerText = "You are ready.";
        canvas.focus();
    };

    socket.on("game-over", (data) => {
        if (data.winner) {
            if (data.winner === playerId) {
                winnerText.innerText = "ðŸ† YOU WON! ðŸ†";
                winnerText.style.color = "#4CAF50";
            } else {
                winnerText.innerText = `Winner: Player ${data.winner.slice(0,4)}`;
                winnerText.style.color = "white";
            }
        } else {
            winnerText.innerText = "Draw / Everyone died";
            winnerText.style.color = "#aaa";
        }
        modal.style.display = "flex";
        readyBtn.style.display = "none";
    });

    restartBtn.onclick = () => {
        modal.style.display = "none";
        readyBtn.style.display = "inline-block";
        readyBtn.disabled = false;
        readyBtn.innerText = "I AM READY";
        readyBtn.style.backgroundColor = "#4CAF50";
        statusText.innerText = "Press Ready to start next round";
    };

    // ==== 3. Network Events ====
    socket.emit("join-room");
    
    socket.on("joined-room", (data) => {
        playerId = data.playerId;
        statusText.innerText = "Connected. Press Ready.";
    });

    socket.on("countdown", num => {
        statusText.innerText = "Game starting in: " + num;
        modal.style.display = "none"; 
        readyBtn.style.display = "inline-block";
    });

    socket.on("ready-timer", num => statusText.innerText = "Waiting for stragglers: " + num);
    
    socket.on("room-updated", data => {
        const readyCount = data.players.filter(p => p.ready).length;
        const total = data.players.length;
        if (!statusText.innerText.includes("starting")) {
            statusText.innerText = `Lobby: ${readyCount}/${total} Ready`;
        }
    });

    // --- Animation State System ---
    let animations = []; 

    socket.on("ability-used", (data) => {
        if (data.ability === "push") {
            animations.push({
                playerId: data.playerId,
                type: "push",
                startTime: Date.now(),
                duration: 200 
            });
        }
    });

    // ==== 4. Rendering Logic ====
    const arenaRadius = 250; 
    let gameState = { players: [] };
    const playerAngles = {};

    socket.on("state-update", data => {
        gameState = data;
        drawArena();
    });

    function drawArena() {
        ctx.clearRect(0,0,canvas.width,canvas.height);

        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);

        // Draw Arena Floor
        ctx.beginPath();
        ctx.arc(0, 0, arenaRadius, 0, Math.PI*2);
        ctx.fillStyle = "#ddd";
        ctx.fill();
        ctx.lineWidth = 5;
        ctx.strokeStyle = "#444";
        ctx.stroke();

        // Filter out finished animations
        const now = Date.now();
        animations = animations.filter(anim => now - anim.startTime < anim.duration);

        // Draw Players
        gameState.players.forEach(p => {
            ctx.save();
            
            // 1. Calculate Rotation
            // We use a threshold of 0.1 for physics/rotation calculations
            if (Math.abs(p.vx) > 0.1 || Math.abs(p.vy) > 0.1) {
                playerAngles[p.id] = Math.atan2(p.vy, p.vx);
            }
            let angle = playerAngles[p.id];
            if (angle === undefined) angle = Math.PI / 2;

            // 2. Position the context
            ctx.translate(p.x, p.y);
            ctx.rotate(angle - Math.PI / 2);

            // --- Handle Push Animation (Lunge) ---
            const activeAnim = animations.find(a => a.playerId === p.id && a.type === "push");
            if (activeAnim) {
                const progress = (now - activeAnim.startTime) / activeAnim.duration;
                // Lunge effect
                const lungeDistance = 15; 
                const offset = Math.sin(progress * Math.PI) * lungeDistance;
                ctx.translate(0, offset); 

                // Shockwave
                ctx.beginPath();
                ctx.arc(0, 40, 20 + (progress * 30), 0, Math.PI, false);
                ctx.lineWidth = 5 - (progress * 5);
                ctx.strokeStyle = `rgba(255, 255, 255, ${1 - progress})`; 
                ctx.stroke();
            }

            // 3. Status Effects
            if (p.isInvulnerable) {
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI*2);
                ctx.fillStyle = "rgba(255, 215, 0, 0.5)"; 
                ctx.fill();
            } else if (p.isSliding) {
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI*2);
                ctx.fillStyle = "rgba(0, 255, 255, 0.5)"; 
                ctx.fill();
            }

            // 4. Select Sprite (Animation Logic)
            let sprite;
            const isMe = (p.id === playerId);
            let isMoving;

            if (isMe) {
                // For MY PLAYER: Check Input Directly for immediate stop
                // If any key is pressed, we are moving. If not, we are idle.
                isMoving = myInput.up || myInput.down || myInput.left || myInput.right;
            } else {
                // For ENEMY: We rely on Velocity
                // We increase threshold to 0.5 so they snap to idle faster during friction
                isMoving = Math.abs(p.vx) > 0.5 || Math.abs(p.vy) > 0.5;
            }

            // If "Slide" ability is active, strictly show Run animation (optional)
            // or just rely on physics. Usually sliding implies movement.
            if (p.isSliding) isMoving = true;

            if (!isMoving) {
                // Standing still
                sprite = isMe ? imgPlayerIdle : imgEnemyIdle;
            } else {
                // Running: Switch between Run1 and Run2 every 150ms
                const frame = Math.floor(now / 150) % 2; 

                if (isMe) {
                    sprite = (frame === 0) ? imgPlayerRun1 : imgPlayerRun2;
                } else {
                    sprite = (frame === 0) ? imgEnemyRun1 : imgEnemyRun2;
                }
            }

            // 5. Draw Image
            if (!p.alive) ctx.globalAlpha = 0.5;

            const size = 60; 
            ctx.drawImage(sprite, -size/2, -size/2, size, size);

            ctx.restore(); 

            // 6. Draw ID
            ctx.fillStyle = "black";
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "center";
            ctx.fillText(p.id.slice(0,4), p.x, p.y + 40);
        });

        ctx.restore();
    }
</script>
</body>
</html>